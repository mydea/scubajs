<!DOCTYPE html>
<html>
<head lang="en">
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>scuba.js Documentation</title>

	<link href="css/prism.css" type="text/css" rel="stylesheet">
	<link href="css/style.css" type="text/css" rel="stylesheet">
</head>
<body class="language-javascript">

<ul class="nav">
	<li><a href="#what-does-it-dp">What does it do?</a></li>
	<li><a href="#how-does-it-work">How does it work?</a></li>
	<li><a href="#prerequisites">Prerequisites</a></li>
	<li><a href="#usage">Usage</a></li>
	<li><a href="#options">Options</a></li>
	<li><a href="#downsync">Down Sync</a></li>
	<li><a href="#routes">Routes</a></li>
	<li><a href="#localdb">LocalDB</a></li>
	<li><a href="#events">Events</a></li>
	<li><a href="#miscellaneous">Miscellaneous</a></li>
</ul>

<div class="wrapper">

	<h1>scuba.js Documentation</h1>

	<h2 id="what-does-it-do">What does it do?</h2>
	<p>

	</p>

	<h2 id="how-does-it-work">How does it work?</h2>
	<ol>
		<li>
			scuba.js first gets all the data for your app. This process is called <strong>down sync</strong>. The data is then
			stored in IndexedDB in the browser.
		</li>
		<li>
			When the down sync has finished, scuba will begin to intercept all calls to <code>$.ajax</code>. This means
			that you don't have to change anything about your code as long as you use $.ajax for all requests.
		</li>
		<li>
			When a call is made to $.ajax, it goes through scuba.js. It will then determine if a matching route has been specified.
		</li>
		<li>
			If no matching route is found, the request is made to the server. In this case, scuba.js does nothing.
		</li>
		<li>
			If a matching route is found, scuba will first call the route's <code>action</code> function of the route.
		</li>
		<li>
			When the action is finished, the <code>data</code> function of the route is called. This function determies what should be returned to
			the ajax call.
		</li>
		<li>
			When the data function is finished, the resulting data goes through the <code>format</code> function of the route.
			In here, you can actually "style" the returned data.
		</li>
		<li>
			For all POST, PUT and DELETE calls, and entry is automatically added to scuba's queue.
			Scuba.js works through this queue as soon as the browser is online, in the same order as the requests came in.
		</li>
	</ol>


	<h2 id="prerequisites">Prerequisites</h2>
	<p>
		scuba.js has once dependency: jQuery. Additionally, you might want to include an IndexedDB-Polyfill like
		<a href="https://github.com/axemclion/IndexedDBShim" target="_blank">IndexedDBShim</a> if you want to
		support older browsers -
		<a href="http://caniuse.com/#feat=indexeddb" target="_blank">native IndexedDB support is good, but not perfect</a>,
		with a polyfill most relatively modern browsers	are supported.
	</p>
	<p>
		scuba.js can be installed via bower with the following command:
	</p>
	<pre><code>bower install scubajs --save</code></pre>

	<p>
		Alternatively you can also simply download the file scuba.js manually from Github.
	</p>

	<h2 id="usage">Usage</h2>
	<p>
		Include jQuery and scuba.js at the end of your page:
	</p>
	<pre><code lang="language-html">&lt;script src="bower_components/jquery/dist/jquery.min.js">&lt;/script>
&lt;script src="bower_components/prismjs/scuba.min.js">&lt;/script></code></pre>

	<p>
		Then, initialise scuba.js when you're ready:
	</p>

	<pre><code>var scuba = $.scuba({
	// options go here
});</code></pre>

	<h2 id="options">Options</h2>
	<p>
		scuba.js provides a bunch of configuration options. They can be separated in two parts: basic configuration and
		route configuration. Route configuration will be covered separately.
	</p>
	<p>
		The following configuration options are available, with their respective default values:
	</p>
	<pre><code>var scuba = $.scuba({
	syncRetry: 10000,
	downSyncTimeout: 10000,
	remoteIfOnline: false,
	includeDefaultRoutes: false,
	apiBaseUrl: "",
	localDBClass: null,
	namespace: "scuba",
	noConflict: false,
	queueIfError: "continue",
	queueIfError: "continue",
	defaultFormat: function(data) { return data; }
});</code></pre>

	<h3>syncRetry</h3>
	<p>
		The time in milliseconds to wait between failed sync tries.
	</p>

	<h3>downSyncTimeout</h3>
	<p>
		Time in milliseconds to wait for the down sync to finish.
		When this time has passed and one or more down sync routes have not finished yet, scuba.js will be initialised as
		offline.
	</p>

	<h3>remoteIfOnline</h3>
	<p>
		If false, all ajax calls will be routed through scuba.js, even if you are online. If true, calls will only go
		through scuba.js if you are offline.
	</p>

	<h3>includeDefaultRoutes</h3>
	<p>
		If set to true, scuba.js will try to match undefined routes to a standard pattern. This might work for your app,
		but only if your REST API follows a certain pattern. It will match routes as follows:
	</p>
	<ul>
		<li>
			<strong>GET /users</strong>
			<br/>&rarr; <code>data: function() {return this.findAll("users");}</code>
		</li>
		<li>
			<strong>GET /users/1</strong>
			<br/>&rarr; <code>data: function(options, id) {return this.findById("users", id);}</code>
		</li>
		<li>
			<strong>POST /users</strong>
			<br/>&rarr; <code>action: function(options) {return this.rowInsert("users", options.data);}</code>
			<br/>&rarr; <code>data: function(options) {return this.findById("users", options.data.id);}</code>
		</li>
		<li>
			<strong>PUT /users/1</strong>
			<br/>&rarr; <code>action: function(opt, id) {return this.rowUpdate("users", id, opt.data);}</code>
			<br/>&rarr; <code>data: function(options, id) {return this.findById("users", id);}</code>
		</li>
		<li>
			<strong>DELETE /users/1</strong>
			<br/>&rarr; <code>action: function(opt, id) {return this.rowDelete("users", id);}</code>
			<br/>&rarr; <code>data: function() {return {};}</code>
		</li>
	</ul>

	<p>
		<code>users</code> can be replaced by any known model which was included in the down sync. All other routes
		are not matched and therefore not catched by scuba.js. If a route is not matched (either because it deviates
		from this standard format, or if includeDefaultRoutes is set to false), the request is sent directly to the server.
	</p>
	<p>
		Please note that you have to set apiBaseUrl in order to make this work - if it is not set, no default routes will be included!
	</p>

	<h3>apiBaseUrl</h3>
	<p>
		This is necessary in order to use includeDefaultRoutes. It should be a route without trailing slash, for example:
		<code>http://yourapi.com/v1</code>.
	</p>

	<h3>localDBClass</h3>
	<p>
		If this is set to something other than null, the included LocalDB-Class is overwritten.
		Only do this if you know what you're doing! Your class will need to implement all the functions etc. of
		the included LocalDB class.
	</p>

	<h3>namespace</h3>
	<p>
		The namespace for the IndexedDB and the LocalStorage.
	</p>

	<h3>noConflict</h3>
	<p>
		If this is set to true, no events will be fired on $(window) and $.ajax will not be overridden.
		This is useful for testing. If noConflict is activated, you can use scuba.js via scuba.ajax(...).
	</p>

	<h3>queueIfError</h3>
	<p>
		How should scuba react if an error occurs while working the queue? Possible values are:
	</p>
	<ul>
		<li><code>"continue"</code>: The error-throwing queue item is discarded and the queue continues</li>
		<li>
			<code>"stop"</code>: The queue stops right there. You have to handle the situation manually via the
			<code>onqueuestatuschange</code>-event. You can restart the queue by calling <code>scuba.queueContinue();</code>.
		</li>
		<li>
			<code>funcion(queueItems) {}</code>: You can also pass a function which will be called when a sync error occurs.
			Note that the <code>onqueuestatuschange</code>-event will fire <strong>before</strong> this function is called.
		</li>
	</ul>

	<h3>defaultFormat</h3>
	<p>
		Determines how data should be formatted by default. If no <code>format()</code> function is specified for a route,
		the data will be formatted with this function. For details on how to format data, see the <a href="#routes">section "Routes"</a>.
	</p>

	<h2 id="routes">Routes</h2>
	<p>You have to define the routes your REST-API has. Scuba.js will take the first matching route, and return the according data. Each route has the following attributes:</p>
	<pre><code>routes: [
	{
		type: "get",
		route: "http://yourapi.com/users",
		action: function(options) {
			// Do something before data();
			// For example, insert, delete or update entries
		},
		data: function(options) {
			// This returns either null (for example for a DELETE request)
			// or one of the provided functions of the LocalDB
			// or a promise which has to be resolved manually
		},
		format: function(data, options) {
			// This gets the resolved data from data() and formats it
			// This is the only function that directly returns a value!
		}
	}
]</code></pre>

	<h3>type</h3>
	<p>Type describes the HTTP method that should be matched. It can be either <code class="inline-code">get</code>, <code class="inline-code">post</code>, <code class="inline-code">put</code> or <code class="inline-code">delete</code>. Only routes with a matching </p>

	<h3>route</h3>
	<p>
		This contains the URL that should be matched. It has to be either a full URL complete with http://,
		or just the part after the <code>apiBaseUrl</code>, if it is specified, complete with starting slash.
	</p>
	<pre><code>route: "http://yourapi.com/users",
route: "http://yourapi.com/users/tasks/",
route: "/users"</code></pre>

	<p>
		It is also possible to use route parameters by including <code>!!</code> as a placeholder:
	</p>
	<pre><code>route: "/users/!!"
route: "/users/!!/comments/!!" // multiple placeholders are possible, too</code></pre>

	<p>
		The route segments are later available in the <code>data()</code> function!
	</p>

	<h3>data</h3>
	<p>
		This is the central function which determines what data should be returned by the call. As parameters, it receives the options of the original ajax-request as first parameter, and eventual route segments from placeholders as the following parameters.
	</p>

	<p>
		Inside of the <code>data()</code> function, the LocalDB-object is available via <code>this</code>.
		It provides an easy to use API to the IndexedDB. See <a href="#localdb">section "LocalDB"</a> for the function
		that are provided.
	</p>

	<p>
		The data function has to return either <code>null</code> (which might be useful for DELETE requests or similar),
		or a promise which has to be resolved. The LocalDB-function automatically return promises for you, so you can
		simply return them. If you want to do something other/specific, you have to build a promise manually and resolve & return it.
		A simple example built with jQuery.Deferred() (which is not, technically, a promise, but it works well enough):
	</p>

	<pre><code>data: function(options) {
	var deferred = $.Deferred();

	// Do something
	var data = {};
	deferred.resolve(data);

	return deferred.promise();
}</code></pre>

	<p>
		You <strong>cannot</strong> return a value other than a promise or null. <code>data()</code> is the only function which is required for routes - while you can omit action and format, you have to
		specify data, even if you only return null.
	</p>

	<h3>action</h3>
	<p>
		This function is called before the data is returned. Only when this function has finished, data will be called!
		<code>action()</code> is optional, you can omit it, for example for GET requests where you only return data.
	</p>

	<p>
		Like <code>data()</code>, <code>action()</code> has to return a promise - only that for <code>action()</code>,
		you do not have the option to return null! Again, LocalDB's built-in functions like <code>this.rowInsert()</code>
		or <code>this.rowDelete()</code> return promises, so normally you shouldn't have to concern yourself with this.
	</p>
	<p>
		<code>action()</code> receives the same parameters as data: first, the options of the ajax request, and then optionally
		the route parameters.
	</p>

	<h3>format</h3>
	<p>
		This function receives the resolved data from <code>data()</code> as first parameter and the options of the original ajax request as the second parameter. Here, you can work with the data and format the output. The value that is returned from this
		function is the value the <code>success()</code> function of the ajax call will receive.
	</p>

	<h3>Examples</h3>
	<p>
		A few examples of common scenarios:
	</p>
	<pre><code>var scuba = $.scuba({
	routes: [
		{
			route: "/tasks",
			type: "get",
			data: function() {
				return this.findAll("tasks");
			},
			format: function(data) {
				return {
					model: "tasks",
					tasks: data
				}
			}
		},
		{
			route: "/tasks/!!",
			type: "get",
			data: function(options, param1) {
				return this.findById("tasks", param1);
			}
		},
		{
			route: "/tasks",
			type: "post",
			action: function(options) {
				return this.rowInsert("tasks", options.data);
			},
			data: function(options) {
				return this.findById("tasks", options.data.id);
			}
		},
		{
			route: "/tasks/!!",
			type: "put",
			action: function(options, param1) {
				return this.rowUpdate("tasks", param1, options.data);
			},
			data: function(options, param1) {
				return this.findById("tasks", param1);
			}
		},
		{
			route: "/tasks/!!",
			type: "delete",
			action: function(options, param1) {
				return this.rowDelete("tasks", param1);
			},
			data: function() {
				return null;
			},
			format: function(data) {
				return {
					deleted: true
				};
			}
		},
		{
			// a more custom approach
			route: "/tasks/doSomethingSpecial",
			type: "get",
			data: function(options) {
				var deferred = $.Deferred();

				setTimeout(function() {
					var data = "this is a simple text";
					deferred.resolve(data);
				}, 1000);

				return deferred.promise();
			},
			format: function(data) {
				return "We can simply return text: "+data;
			}
		},
		{
			// multiple actions
			route: "/tasks/!!",
			type: "delete",
			action: function(options, param1) {
				var deferred = $.Deferred();

				this.rowDelete("tasks", param1).then(function() {
					this.findById("users", options.data.user.id).then(function(user) {
						user.task_count--;
						self.rowUpdate("users", user.id, user).then(function() {
							deferred.resolve(null);
						});
					});
				});

				return deferred.promise();
			}
		}
	]
});</code></pre>

	<h2 id="localdb">LocalDB</h2>
	<p>Inside of the <code class="inline-code">data</code> and the <code>action</code> function of a specified route, the LocalDB-Object is available via <code class="inline-code">this</code>. This object provides convenient access to IndexedDB. It has the following functions:</p>

	<pre><code>data: function() {
	var table = "users";
	var id = 1;

	this.findAll(table);
	this.findById(table, id);
	this.findByAttributes(table, {
		lastname: "Smith",
		"is_admin": true
	}); // Only entries where all attributes match are returned
	this.findCusom(table, function(item) {
		// loops through all items of the table
		// and include only the ones where this function returns true
		return item.is_admin;
	});
	this.rowInsert(table, data);
	this.rowUpdate(table, id, data);
	this.rowDelete(table, id);
}</code></pre>

	<p>Please note that all of these work async. This means that you cannot do something like <code class="inline-code">findAll("users").slice(0,5)</code> because it actually returns a promise, not an array. If you want to work with the real data, you have to do it in the <code class="inline-code">format</code> function, which receives the resolved promise.</p>

	<p>
		Note that normally you will want to do <code>rowInsert()</code>, <code>rowUpdate()</code> and <code>rowDelete()</code>
		inside of <code>action()</code> and not <code>data()</code>;
	</p>

	<h2 id="events">Events</h2>
	<p>
		There are four events available to work with scuba.js:
	</p>
	<pre><code>var scuba = $.scuba();

		// When the offline database is ready - when this event fires, scuba is ready!
		var offlineReady = function(isOfflineReady) {
		// isOfflineReady is either true or false
		};
		scuba.onofflineready(offlineReady);
		// or, alternative code:
		$(window).on("offlineready", offlineReady);

		// This is fired whenever the application changes from online to offline
		// or from offline to online
		var offlineStatusChange = function(isOffline) {
		// isOffline is either true or false
		};
		scuba.onofflinestatuschange(offlineStatusChange);
		// or, alternative code:
		$(window).on("offlinestatuschange", offlineStatusChange);

		// Fired whenever the application starts or stops syncing
		var sync = function(syncInProgress) {
		// syncInProgress is either true or false
		};
		scuba.onsync(sync);
		// or, alternative code:
		$(window).on("sync", sync);

		// Fired when the queue changes in any way
		var queueStatusChange = function(e) {
		// e = {...}
		};
		scuba.onqueuestatuschange(queueStatusChange);
		// or, alternative code:
		$(window).on("queuestatuschange", queueStatusChange);
	</code></pre>

	<p>Some things to keep in mind when working with scuba's events:</p>
	<ul>
		<li>
			The <code>offlineready</code> event is called exactly once after initialisation.
			Its parameter is false if no data is in the local database, in this case scuba will do nothing.
		</li>
		<li>
			The <code>queuestatuschange</code> event is called: when an element is added to the queue, an element is removed from the queue,
			or a queue error occurs. This means, that it is called right after you make a POST, PUT or DELETE call via $.ajax().
		</li>
		<li>
			<code>queuestatuschange</code> has one paramater, which is an object with the following syntax:
			<pre><code>{
				status: "OK", // or "ERROR"
				queueLength: 2,
				nextElement: {...},
				queue: [...]
				}</code></pre>
		</li>
		<li>
			<code>sync</code> is called when scuba starts or stops syncing. Its parameter is either true if it is currently syncing or elsewise false.
		</li>
		<li>
			<code>offlinestatuschange</code> is called whenever the application changes between offline and online status.
			Its parameter is true if the application is currently offline, elsewise it is false.
		</li>
	</ul>



	<h2 id="miscellaneous">Miscellaneous</h2>
	<p>
		Other things which might be good to know:
	</p>
	<ul>
		<li>
			scuba.js converts all ids to strings.
			This is neccessary because IndexedDB will not find entries if you search for "1" and the ID is the integer 1.
			If you want to return the id as integer, you have to cast it in the format (or defaultFormat) functions.
		</li>
		<li>
			While all data is saved in IndexedDB, the queue is saved in LocalStorage. This is because the IndexedDB database
			is dropped and re-initialised with each down sync, while the queue is persisted across various down syncs.
		</li>
	</ul>
</div>


<script src="../bower_components/jquery/dist/jquery.min.js"></script>
<script src="js/prism.js"></script>
</body>
</html>